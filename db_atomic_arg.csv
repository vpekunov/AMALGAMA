0,body,"#include <stdlib.h>\n"
1,body,"#include <stdio.h>\n"
2,body,"#include <math.h>\n"
3,body,"#pragma auto for\n"
4,body,"#pragma auto omp for\n"
5,body,"#pragma auto gpu for\n"
6,body,"#pragma auto parallelize\n"
7,body,"#pragma auto pure(malloc,fabs,free,sizeof,omp_get_wtime)\n"
8,body,"#define BASE_PARALLEL 1\n"
9,body,"#define theta 1.83\n"
10,body,"#define NX 40\n"
11,body,"#define NY 40\n"
12,body,"#define h 0.1\n"
13,body,"#define NP 15000\n"
14,body,"#define U1 200\n"
15,body,"#define U2 5000\n"
16,body,"#define e -1.5E-13\n"
17,body,"#define m 1E-11\n"
18,body,"#define e0 8.85E-12\n"
19,body,"#define V (h*h)\n"
20,body,"#define tau 0.000015\n"
21,body,"#define T 0.09\n"
22,body,"#define POISSON_EPS 0.01\n"
23,body,"#define TOL_EPS 0.25\n"
24,args,
24,ret,"int "
24,name,main
26,op,"double * U  = (double *)malloc(NY*NX*sizeof(double))"
27,op,"double * UU = (double *)malloc(NY*NX*sizeof(double))"
28,op,"double * EX = (double *)malloc(NY*NX*sizeof(double))"
29,op,"double * EY = (double *)malloc(NY*NX*sizeof(double))"
30,op,"double * PX = (double *)malloc(NP*sizeof(double))"
31,op,"double * PY = (double *)malloc(NP*sizeof(double))"
32,op,"int * X = (int *)malloc(NP*sizeof(int))"
33,op,"int * Y = (int *)malloc(NP*sizeof(int))"
34,op,"double ro[NY][NX]"
35,op,"split_private double t"
36,op,"split_private double tm"
37,op,"split_private int i, j"
38,init,"i = 0"
38,cond,"i < NY"
38,chng,i++
39,init,"j = 0"
39,cond,"j < NX"
39,chng,j++
41,op,"UU[i*NX+j] = j == NX-1 ? U2 : j == NX/2 && (i < NY/4 || i > 3*NY/4) ? U1 : 0.0"
42,op,"EX[i*NX+j] = 0.0"
43,op,"EY[i*NX+j] = 0.0"
45,init,"i = 0"
45,cond,"i < NP"
45,chng,i++
47,op,"int x, y"
48,op,"PX[i] = 0.5*NX*h*rand()/RAND_MAX"
49,op,"PY[i] = NY*h*rand()/RAND_MAX"
50,op,"x = PX[i]/h"
51,op,"y = PY[i]/h"
52,cond,"x < 0"
53,op,"x = 0"
55,cond,"x > NX-1"
56,op,"x = NX-1"
57,cond,"y < 0"
58,op,"y = 0"
60,cond,"y > NY-1"
61,op,"y = NY-1"
62,op,"X[i] = x"
63,op,"Y[i] = y"
65,op,"tm = omp_get_wtime()"
66,init,"t = 0.0"
66,cond,"t < T"
66,chng,"t += tau"
68,op,"unsigned int n[NY][NX] = { 0 }"
69,op,"double err"
70,op,"int ptr = 0"
71,init,"i = 0"
71,cond,"i < NY"
71,chng,i++
72,init,"j = 0"
72,cond,"j < NX"
72,chng,j++
72,chng," ptr++"
73,op,"U[ptr] = UU[ptr]"
74,init,"i = 1"
74,cond,"i < NY - 1"
74,chng,i++
75,init,"j = 1"
75,cond,"j < NX - 1"
75,chng,j++
77,op,"EX[i*NX+j] = -(U[i*NX+j+1]-U[i*NX+j-1])/2.0/h"
78,op,"EY[i*NX+j] = -(U[(i+1)*NX+j]-U[(i-1)*NX+j])/2.0/h"
80,body,"#pragma omp parallel for if(BASE_PARALLEL) private(i) num_threads(split_tune)\n"
81,init,"i = 0"
81,cond,"i < NP"
81,chng,i++
83,op,"PX[i] += tau*e*EX[Y[i]*NX+X[i]]/m"
84,op,"PY[i] += tau*e*EY[Y[i]*NX+X[i]]/m"
86,body,"#pragma omp parallel for if(BASE_PARALLEL) private(i) num_threads(split_tune)\n"
87,init,"i = 0"
87,cond,"i < NP"
87,chng,i++
89,op,"int x = PX[i]/h"
90,op,"int y = PY[i]/h"
91,cond,"x < 0"
92,op,"x = 0"
94,cond,"x > NX-1"
95,op,"x = NX-1"
96,cond,"y < 0"
97,op,"y = 0"
99,cond,"y > NY-1"
100,op,"y = NY-1"
101,op,"Y[i] = y"
102,op,"X[i] = x"
103,op,n[y][x]++
105,init,"i = 0"
105,cond,"i < NY"
105,chng,i++
106,init,"j = 0"
106,cond,"j < NX"
106,chng,j++
107,op,"ro[i][j] = n[i][j]*e/V"
110,op,"err = 0.0"
111,body,"#pragma omp parallel for if(BASE_PARALLEL) private(i,j) num_threads(split_tune)\n"
112,init,"i = 1"
112,cond,"i < NY - 1"
112,chng,i++
113,init,"j = 1+(i-1)%2"
113,cond,"j < NX - 1"
113,chng,j+=2
115,op,"int ptr = i*NX + j"
116,cond,"!(j == NX/2 && (i < NY/4 || i > 3*NY/4))"
118,op,"double _new = (1-theta)*UU[ptr] + theta/4.0*(UU[ptr-1]+UU[ptr+1]+UU[ptr+NX]+UU[ptr-NX]-h*h*ro[i][j]/e0)"
119,op,"double loc_err = fabs(UU[ptr] - _new)"
120,cond,"loc_err > err"
121,op,"err = loc_err"
122,op,"UU[ptr] = _new"
125,body,"#pragma omp parallel for if(BASE_PARALLEL) private(i,j) num_threads(split_tune)\n"
126,init,"i = 1"
126,cond,"i < NY - 1"
126,chng,i++
127,init,"j = 1+i%2"
127,cond,"j < NX - 1"
127,chng,j+=2
129,op,"int ptr = i*NX + j"
130,cond,"!(j == NX/2 && (i < NY/4 || i > 3*NY/4))"
132,op,"double _new = (1-theta)*UU[ptr] + theta/4.0*(UU[ptr-1]+UU[ptr+1]+UU[ptr+NX]+UU[ptr-NX]-h*h*ro[i][j]/e0)"
133,op,"double loc_err = fabs(UU[ptr] - _new)"
134,cond,"loc_err > err"
135,op,"err = loc_err"
136,op,"UU[ptr] = _new"
139,init,"j = 0"
139,cond,"j < NX"
139,chng,j++
141,op,"UU[j] = UU[NX + j]"
142,op,"UU[(NY-1)*NX + j] = UU[(NY-2)*NX + j]"
145,cond,"err > POISSON_EPS"
146,op,
148,init,"i = 0"
148,cond,"i < NY"
148,chng,i++
150,init,"j = 0"
150,cond,"j < NX"
150,chng,j++
151,op,"printf(""%lf\\t"", UU[i*NX+j])"
152,op,"printf(""\\n"")"
154,arg,0
