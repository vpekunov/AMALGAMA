  Это система порождения, реконструкции и трансформации программ АМАЛЬГАМА (ранее
была известна под названием PGEN++).
  Система распространяется AS IS.

                                VERSION 1.0 (2003-2024, В.В.Пекунов)

  Подробно описана в книге
"Пекунов В.В. Система порождения, реконструкции и преобразования программ PGEN++. -
LAP LAMBERT Academic Publishing, 2020. - 173 с.", которую автор может выслать для
ознакомления по электронной почте, обратиться можно на адрес pekunov@mail.ru
  В настоящее время данная книга выложена в папку Documentation
  Если Вы захотите сослаться на работы автора, посвященные данной системе, можно
сослаться на одну-две из следующих:
 1.Пекунов В.В. Автоматизация параллельного программирования при
   моделировании многофазных сред. Оптимальное распараллеливание //
   Автоматика и телемеханика.- 2008. - №7. - С.170-180.
 2.Пекунов В.В. Новые методы параллельного моделирования распространения
   загрязнений в окрестности промышленных и муниципальных объектов
   // Дис. докт. тех. наук. - Иваново, 2009. - 274 с.
 3.Пекунов В.В. Система порождения, реконструкции и преобразования программ АМАЛЬГАМА //
   Свидетельство о государственной регистрации программы для ЭВМ №2020664685. - М.: РОСПАТЕНТ, 16.11.2020.
 4.Пекунов В.В. Система порождения, реконструкции и преобразования программ PGEN++. -
   LAP LAMBERT Academic Publishing, 2020. - 173 с.

  Здесь представлена полная версия (PGEN++/АМАЛЬГАМА) системы, которая, помимо генерации
программ по визуальной схеме или упрощенному текстовому описанию
(описание->визуальная_модель->программа), также умеет решать ряд обратных задач,
связанных с распознаванием смысла текстов и программ. В частности, можно реконструировать
описание исходной модели по порожденной программе (реализовано в некоторых учебных примерах) или по
текстовому описанию задачи на русском языке. Также написан модуль, осуществляющий
рапознавание C-программы со вставкой в нее директив распараллеливания Cilk/Cilk++
(автоматическое распараллеливание C-программ).
  Подсистема написана на Lazarus, использует PHP (порождение),
авторский Prolog MicroBrain (дедуктивный вывод фрагментов модели, трансформации),
SNOBOL (перевод с обобщенного языка на конкретные для некоторых моделей).

------------------------------------------------------------------------
                           ПОДГОТОВКА И ЗАПУСК

  Распакуйте архив в отдельный каталог. [Вы можете воспользоваться уже
скомпилированными файлами (в версии для Windows) или самостоятельно скомпилировать
систему (проекты Automodelling, Params, xpathInduct, Grammar для среды Lazarus; проекты link-grammar-5.3.0,
NeuroNet, Predicates, prolog_micro_brain.dir, PrologIntrf для C++)]. Дополнительные
системы (PHP, SNOBOL) интегрированы в проект в версии для Windows и не требуют установки.
  В настоящее время основная часть системы существует в кроссплатформенной версии для Windows/Linux.

  Для инсталляции под Linux:
  а) Установите Lazarus или, в крайнем случае, Free Pascal (fpc 3.2.0 и выше)
  б) Установите PHP (php), желательно не ниже версии 8.0
  в) Установите php-xml и net-tools
  г) Установите консоли ru_RU.UTF-8, en_US.UTF-8
  д) Выполните скрипт install.sh
  у) Скомпилируйте в Lazarus проекты Automodelling.lpi и Params.lpi

  Запустите файл Automodeling[.exe]. Появляется окно редактирования моделей,
в которое можно "перетащить" элементы модели из окна "Классы"
и установить между ними связи.

  Дайте команду Файл/Открыть, зайдите в каталог с программой, выберите
один из xml-файлов с описаниями моделей (находятся в каталоге Examples):
  1. EcologyExprA_KE_RNG_T.xml. Это описание модели для одного из
экспериментов демонстрационной версии, а именно -- турбулентного
обтекания "горячего" одиночного препятствия. Нажмите F9 для запуска
процесса генерации. После проверки модели, устранения избыточных деклараций,
синтаксических преобразований и дополнений будет сгенерирован один из
модулей расчетного блока (его текст на языке C появится в окне программы).
Скомпилировать его не удастся, т.к. прочие модули расчетного блока в демо-
версию не входят. Но можно убедиться, что работает.
  2. EcologyGoettSO2RadDrops_DISS.xml. Это описание очень серьезной
многофазной модели (капельные и газообразные загрязнители, учитываются
конденсация, испарение, излучение, распространение и поглощение SO2) для
оценки реальной экологической ситуации (имеют место выбросы загрязнителей
автотранспортом) на улице ГеттингенШтрассе, Ганновер, Германия.
  Нажмите F9 для запуска процесса генерации. Также появится текст расчетного
файла на языке C.
  3. System.xml [Пока только для Windows]. Это описание процесса решения системы из двух
обыкновенных дифференциальных уравнений методом Эйлера. В меню
"Генерация\Язык конкретизации" выберите нужный язык конечного кода,
нажмите F9. Полученный файл можно скомпилировать и запустить -- он
работоспособен, только потребует наличия файла SMap.map -- его можно
найти в каталоге программы.
  Это не очень серьезный пример, зато полностью работоспособный.
  4. Manip.xml. Этот пример потребует установленной на этом же компьютере
системы MATLAB 6.5 и выше. Нажмите F9, затем Yes/Да (если у Вас есть MATLAB).
 По кинематической модели манипулятора робота генерируется расчетный
M-файл, находящий уравнения связи координат манипулятора, который можно
исполнить и получить соответствующие уравнения.

  Примеры решения обратных задач:

  Дайте команду Файл/Индукция модели. Появится окно, в котором можно попробовать
один из следующих примеров:
  1. В поле "Все классы" выберите раздел "clsSimpleProgs" и перетащите его мышью
в поле "Выбранные классы". Нажмите кнопку "Загрузить программу" и выберите
файл SimpleProg.c. Он загрузится в поле "Исходный текст" --
это простая C-программа, сгенерированная ранее системой PGEN++. В поле с вариантами
"Programmatical" и "Russian" поставьте отметку напротив "Programmatical". Нажмите кнопку
"Индукция", и через некоторое время система распознает исходную модель, по которой
была сгенерирована SimpleProg.c. Эта модель загрузится в редактор, можно закрыть
окно "Индукция моделей" и посмотреть восстановленную модель. Более того, можно
нажать F9 и убедиться, что по данной модели будет порождена программа, эквивалентная
исходной SimpleProg.c.
  2. В поле "Все классы" выберите раздел "clsSimpleProgs" и перетащите его мышью
в поле "Выбранные классы". Нажмите кнопку "Загрузить программу" и выберите из
каталога файл SimpleProg.txt. Он загрузится в поле "Исходный текст" --
это текстовое описание решаемой задачи на упрощенном русском языке. В поле с вариантами
"Programmatical" и "Russian" поставьте отметку напротив "Russian". Нажмите кнопку
"Индукция", и через некоторое время система транслирует описание в модель, по которой
можно будет сгенерирована решающая программа. Эта модель загрузится в редактор, можно закрыть
окно "Индукция моделей" и посмотреть восстановленную модель. Нажав F9, можно убедиться, что
по данной модели будет порождена программа, решающая поставленную задачу.
  3. В поле "Все классы" выберите раздел "clsCilkParallelize" (найдите его в разделе
"clsSimpleMacros") и перетащите его мышью в поле "Выбранные классы". Нажмите кнопку
"Загрузить программу" и выберите файл SimpleCilk.cpp. Он загрузится
в поле "Исходный текст" -- это простая вычислительная C-программа, написанная программистом.
Нажмите кнопку "Индукция", и через некоторое время система проанализирует программу и вставит
в нее директивы распараллеливания Cilk/Cilk++. Результат появится в поле "После трансформации",
можно его посмотреть и убедиться в корректности программы.
  4. В поле "Все классы" выберите раздел "clsAtomicParallelize" (найдите его в разделе
"clsSimpleMacros") и перетащите его мышью в поле "Выбранные классы". Нажмите кнопку
"Загрузить программу" и выберите файл SimpleAtomicLens1.c. Он загрузится
в поле "Исходный текст" -- это простая вычислительная C-программа, написанная программистом.
Нажмите кнопку "Индукция", и через некоторое время система проанализирует программу и вставит
в нее директивы распараллеливания с применением сверхоптимистичных вычислений. Результат
появится в поле "После трансформации", можно его посмотреть и убедиться в корректности программы.
  5. В поле "Все классы" выберите раздел "clsGPUParallelize" (найдите его в разделе
"clsSimpleMacros") и перетащите его мышью в поле "Выбранные классы". Нажмите кнопку
"Загрузить программу" и выберите файл SimpleGPU.cpp. Он загрузится
в поле "Исходный текст" -- это простая вычислительная C-программа, написанная программистом.
Нажмите кнопку "Индукция", и через некоторое время система проанализирует программу и переведет
ее на расширение языка C++, вставив директивы распараллеливания для запуске на многоядерной
графической видеокарте. Результат появится в поле "После трансформации", можно его посмотреть
и убедиться в корректности программы.

  Примеры работы с окном приобретения знаний

  Реализован автоматический вывод шаблонных и XPath-правил для решения обратных задач по типу 2-й из
вышеперечисленных примеров. Данные правила генерируются по обучающим парам вида
"предложение_на_русском_языке_описывающее_объект_модели"<=>"описываемый_объект_модели".
Реализация процесса генерации не лишена недостатков, но на наборах непротиворечивых и однозначно
трактуемых обучающих пар дает приемлемые результаты.
  Посмотреть готовый проект приобретения знаний можно, дав команду "Файл\Индукция правил", нажав кнопку
"Загрузить проект" в нижней части окна и выбрав файл SimpleProgs.prj -- это проект приобретения знаний
о генерации модели порождения по текстовому описанию задачи для системы классов, описывающих решение
простых проблем обработки векторных данных. В нижнем поле можно будет просмотреть набор обучающих пар,
затем нажать кнопку "Сгенерировать распознающие скрипты" и дождаться сообщения об успешной генерации
шаблонных и XPath-правил. Нажмите кнопку "Yes", дождитесь появления информационного окна и нажмите "Ok".
  После этого в поле "im-файл" появится набор сгенерированных XPath-правил. Также можно просмотреть
сгенерированные распознающие шаблоны -- выберите в поле "Классы" ветвь "clsSimpleProgs" и в ней выделите
какой-либо терминальный класс, например, "clsSimpleProgram" -- в поле распознающий скрипт появится текст
распознающего шаблона -- группы регулярно-логических выражений.
  В поле "Рабочий журнал" можно просмотреть различную отладочную информацию о ходе процесса приобретения
знаний.
